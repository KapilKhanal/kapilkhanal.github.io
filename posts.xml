<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Kapil Khanal</title>
<link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts.html</link>
<atom:link href="https://github.com/KapilKhanal/kapilkhanal.github.io/posts.xml" rel="self" type="application/rss+xml"/>
<description>Personal Portfolio of Kapil Khanal</description>
<image>
<url>https://quarto.org/quarto.png</url>
<title>Kapil Khanal</title>
<link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts.html</link>
</image>
<generator>quarto-1.7.32</generator>
<lastBuildDate>Sun, 27 Jul 2025 00:00:00 GMT</lastBuildDate>
<item>
  <title>Workshop on Differentiable Marine Hydrodynamics Simulations and its Applications using MarineHydro.jl</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/marinehydro-workshop/</link>
  <description><![CDATA[ 




<blockquote class="blockquote">
<p>“Understanding and predicting wave-structure interactions is central to the design and operation of offshore systems—from floating wind turbines and wave energy converters to autonomous marine platforms.”</p>
</blockquote>
<hr>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>Understanding and predicting wave-structure interactions is central to the design and operation of offshore systems—from floating wind turbines and wave energy converters to autonomous marine platforms. Traditionally, these interactions are modeled using boundary element method (BEM) solvers based on linear potential flow theory. However, a major limitation of existing BEM solvers is their inability to provide sensitivities (derivatives) of hydrodynamic quantities with respect to design variables such as geometry, wave frequency, or device layout. These sensitivities are essential for enabling modern workflows in design optimization, control co-design, uncertainty quantification, and physics-informed machine learning.</p>
<p>Without access to gradients, engineers are forced to rely on derivative-free methods (e.g., parameter sweeps, heuristics, or surrogate models without sensitivity guidance), which scale poorly and often miss optimal solutions in high-dimensional design spaces. This bottleneck has hindered progress in applying scalable, gradient-based optimization methods—now common in aerospace, robotics, and machine learning—to the marine energy sector.</p>
<p>This workshop introduces MarineHydro.jl, a fully differentiable BEM solver that unlocks access to exact sensitivities of hydrodynamic coefficients through reverse-mode automatic differentiation. Developed in Julia, MarineHydro.jl supports both direct and indirect BEM formulations and includes fast and accurate Green’s function implementations. The workshop is targeted at researchers and practitioners working on design and control of offshore and marine structures, with an emphasis on applications where sensitivity information is essential. Participants will learn to install the solver, perform hydrodynamic simulations, extract gradients, and apply these results to practical case studies.</p>
<p>We begin by reviewing the fundamentals of differentiable programming and its potential usage/implementation in BEM software common in marine hydrodynamics.</p>
<hr>
</section>
<section id="workshop-overview" class="level2">
<h2 class="anchored" data-anchor-id="workshop-overview">Workshop Overview</h2>
<section id="target-audience" class="level3">
<h3 class="anchored" data-anchor-id="target-audience">Target Audience</h3>
<ul>
<li>Researchers and practitioners working on design and control of offshore and marine structures</li>
<li>Engineers interested in differentiable programming</li>
<li>Students and professionals in marine hydrodynamics and renewable energy</li>
</ul>
</section>
<section id="learning-objectives" class="level3">
<h3 class="anchored" data-anchor-id="learning-objectives">Learning Objectives</h3>
<ul>
<li>Install and configure MarineHydro.jl from GitHub</li>
<li>Perform automatic differentiation</li>
<li>Perform hydrodynamic simulations with BEM formulations</li>
<li>Extract exact sensitivities using automatic differentiation</li>
<li>Understand the fundamentals of differentiable programming</li>
</ul>
<hr>
<hr>
</section>
</section>
<section id="technical-foundations" class="level2">
<h2 class="anchored" data-anchor-id="technical-foundations">Technical Foundations</h2>
<section id="differentiable-programming-in-marine-hydrodynamics" class="level3">
<h3 class="anchored" data-anchor-id="differentiable-programming-in-marine-hydrodynamics">Differentiable Programming in Marine Hydrodynamics</h3>
<p>The workshop covers the fundamentals of differentiable programming as applied to potential flow theory and boundary element methods. Participants will learn:</p>
<ul>
<li><strong>Automatic Differentiation:</strong> How reverse-mode AD enables exact gradient computation</li>
<li><strong>BEM Formulations:</strong> Direct and indirect boundary element method implementations</li>
<li><strong>Green’s Functions:</strong> Efficient and accurate implementations for marine applications</li>
<li><strong>Sensitivity Analysis:</strong> Computing derivatives with respect to geometry, frequency, and layout parameters</li>
</ul>
</section>
</section>
<section id="workshop-materials" class="level2">
<h2 class="anchored" data-anchor-id="workshop-materials">Workshop Materials</h2>
<p>The workshop will include hands-on sessions with:</p>
<ul>
<li><strong>Installation Guide:</strong> Setting up MarineHydro.jl from GitHub, AD backends.</li>
<li><strong>Interactive Pluto Notebook:</strong> Step-by-step examples with live code execution??</li>
<li><strong>Tutorial Notebooks:</strong> Step-by-step examples</li>
</ul>
<section id="interactive-workshop-notebook" class="level3">
<h3 class="anchored" data-anchor-id="interactive-workshop-notebook">Interactive Workshop Notebook</h3>
<p>The workshop includes an interactive Pluto notebook that demonstrates:</p>
<ul>
<li><strong>Setup and Installation:</strong> Getting MarineHydro.jl and dependencies running</li>
<li><strong>Basic BEM Simulations:</strong> Simple hydrodynamic calculations</li>
<li><strong>Automatic Differentiation:</strong> Computing exact sensitivities</li>
<li><strong>Gradient-Based Optimization:</strong> Practical examples with real marine structures</li>
<li><strong>Advanced Features:</strong> Multi-body interactions and layout optimization</li>
</ul>
<p>You can download and run the notebook locally, or view it online. The notebook is designed to be self-contained and includes all necessary code examples.</p>
<p><strong><a href="notebooks/workshop_notebook.jl">Download Workshop Notebook</a></strong> - Interactive Pluto notebook with all workshop examples</p>
<hr>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This workshop enable researchers and practitioners to leverage the full power of gradient-based methods that have transformed other engineering disciplines and bring them to the marine energy sector.</p>
<hr>
<p><em>For more information about MarineHydro.jl, visit the <a href="https://github.com/symbiotic-engineering/MarineHydro.jl">GitHub repository</a>.</em> This software is in initial stages of development and actively looking for contributors and feedback.</p>


</section>

 ]]></description>
  <category>workshop</category>
  <category>marine hydrodynamics</category>
  <category>differentiable programming</category>
  <category>optimization</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/marinehydro-workshop/</guid>
  <pubDate>Sun, 27 Jul 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Derivatives are Cheap and Expensive</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/gradient-based-optimization/derivatives-are-cheap-and-expensive.html</link>
  <description><![CDATA[ 




<blockquote class="blockquote">
<p>“In machine learning, derivatives are cheap. In design optimization, they can be very expensive. Why?”</p>
</blockquote>
<hr>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Gradient-based optimization methods are everywhere, and they are the secret sauce behind intelligent software systems like <strong>ChatGPT</strong> to the optimal design of physical systems such as <strong>satellites, rockets, and airplanes</strong>. Very few people know the parallels between these two systems and how the engineering decision making is similar. This post reviews the methodologies for computing gradients in complex systems, drawing on insights from both machine learning and engineering literature.</p>
<p>Differentiation of modular systems composed of many simple subsystem is cheap and very straight forward to compute using chain rule but what if the complex system is composed of many subsystems that are handled by different sub-contractors and the dataflow is complicated? The subsystems probably have their own ‘constraints’ to be solved and thus each subsystem could be implicit function of the system design variables. This is not really a problem for neural networks but it is a problem for physical systems. How many contractors were there in the Apollo 11 mission? I don’t really know, see <a href="https://apollo11space.com/apollo-program-and-private-companies/">this article on the Apollo Program and Private Companies</a>.</p>
<p>Gradients are essential for sensitivity calculations and optimization of objective (loss) functions. But while gradients are <em>cheap</em> for neural network training, they are often <em>expensive</em> for PDEs and coupled simulations in physical system design. <!-- 
For a technical deep dive into MDO architectures and adjoint methods, see the [main post on Gradient-Based Optimization for Large Systems](index.qmd). --></p>
<hr>
</section>
<section id="why-are-gradients-cheap-for-neural-networks" class="level2">
<h2 class="anchored" data-anchor-id="why-are-gradients-cheap-for-neural-networks">Why Are Gradients Cheap for Neural Networks?</h2>
<ul>
<li><strong>Neural networks</strong> are composed of simple, differentiable operations (dot products, matrix multiplications, simple activation functions).</li>
<li>Automatic differentiation (AD) frameworks (e.g., PyTorch, TensorFlow) efficiently apply the chain rule via backpropagation.</li>
<li>The computational graph can be traversed efficiently, making gradient computation nearly as fast as the forward pass.</li>
<li>Analytical gradients are available for many neural network layers so your AD framework gets to cheat and use them.</li>
</ul>
<hr>
</section>
<section id="why-are-gradients-expensive-for-physical-systems" class="level2">
<h2 class="anchored" data-anchor-id="why-are-gradients-expensive-for-physical-systems">Why Are Gradients Expensive for Physical Systems?</h2>
<ul>
<li><strong>Physical systems</strong> often involve PDEs, legacy code, or black-box simulations.</li>
<li>Simulations may be modular, with neural networks chained to empirical calculations, surrogate models, and numerical solvers.</li>
<li>Gradients may require finite differences (expensive and noisy), symbolic methods (rarely feasible), or custom adjoint/automatic differentiation implementations.</li>
<li>Coupled systems (e.g., multidisciplinary design optimization) require careful management of data flow and execution order.</li>
<li>Adhoc heterogenous assembly of components and simulations.</li>
</ul>
<hr>
</section>
<section id="methods-for-gradient-computation" class="level2">
<h2 class="anchored" data-anchor-id="methods-for-gradient-computation">Methods for Gradient Computation</h2>
<ul>
<li><strong>Finite Differences:</strong> Simple but expensive and prone to numerical error.</li>
<li><strong>Symbolic Differentiation:</strong> Exact but rarely practical for complex or legacy code.</li>
<li><strong>Automatic Differentiation:</strong> Powerful, but requires code to be written in a compatible way.</li>
<li><strong>Adjoint/Linear System Methods:</strong> Set up a global sensitivity equation and solve a linear system—especially useful when the chain rule is unwieldy.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 32%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Finite Differences</td>
<td>Easy to implement</td>
<td>Expensive, noisy, scales poorly</td>
</tr>
<tr class="even">
<td>Symbolic</td>
<td>Exact</td>
<td>Impractical for large/legacy code</td>
</tr>
<tr class="odd">
<td>Automatic Diff (AD)</td>
<td>Efficient, general</td>
<td>Needs compatible code, memory usage</td>
</tr>
<tr class="even">
<td>Adjoint/Linear System</td>
<td>Scales for many inputs</td>
<td>Complex to implement, setup required</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="forward-vs.-adjoint-backward-mode-vs-mixed-mode" class="level2">
<h2 class="anchored" data-anchor-id="forward-vs.-adjoint-backward-mode-vs-mixed-mode">Forward vs.&nbsp;Adjoint (Backward) Mode vs Mixed Mode</h2>
<ul>
<li><strong>Forward mode:</strong> Efficient when there are few inputs (design variables).</li>
<li><strong>Adjoint (backward) mode:</strong> Efficient when there are few outputs (objectives/constraints).</li>
<li>Both are applications of the chain rule, but their efficiency depends on the problem structure.</li>
<li>Sometime mixed mode are efficient combining forward and adjoint mode. This depends on the dataflow and the structure of the system.</li>
</ul>
<hr>
</section>
<section id="modular-systems-mixing-and-matching" class="level2">
<h2 class="anchored" data-anchor-id="modular-systems-mixing-and-matching">Modular Systems: Mixing and Matching</h2>
<p>In real-world modeling, systems are often modular: a neural network, an empirical formula, and a numerical simulation may be chained together. The chain rule applies, but the optimal way to compute derivatives may not be a simple sequential application. A different interpretation of the chain rule is needed. Additionally, in complex multidisciplinary systems, managing the execution order and data flow for derivatives is non-trivial. Frameworks like OpenMDAO use graph algorithms (e.g., NetworkX) to determine the correct order and avoid unnecessary computations so that forward and adjoint computation is scalable.</p>
<hr>
<p>Most automatic differentiation techniques, including backpropagation, can be traced back to constrained optimization and the vast literature on optimal controls. The method of Lagrange multipliers transforms constrained problems into unconstrained ones, providing the foundation for adjoint methods and modern AD frameworks.</p>
<hr>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Although gradients are necessary for scalable optimization, but their cost varies dramatically between fields. It requires understanding the structure of your system—and choosing the right differentiation method, this can make the difference between tractable and intractable optimization. As systems become more modular and complex, hybrid approaches and careful management of forward computation and adjoint derivative computation are increasingly important.</p>
<p>System of systems are becoming more common in the design of systems such as ChatGPT, rockets, airplanes, buildings etc and the only way to scale the ‘training’/ ‘tuning’ / optimization is to use right tools to compute them gradients.</p>
<hr>


</section>

 ]]></description>
  <category>optimization</category>
  <category>sensitivity analysis</category>
  <category>research</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/gradient-based-optimization/derivatives-are-cheap-and-expensive.html</guid>
  <pubDate>Mon, 23 Jun 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>MarineHydro.jl: A Fully Differentiable Boundary Element Solver for Hydrodynamic Sensitivity Analysis</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/marinehydro-julia-package/</link>
  <description><![CDATA[ 




<section id="research-overview" class="level2">
<h2 class="anchored" data-anchor-id="research-overview">Research Overview</h2>
<p><strong>MarineHydro.jl: A Fully Differentiable Boundary Element Solver for Hydrodynamic Sensitivity Analysis of Wave-Structure Interactions</strong></p>
<p>This work presents a novel implementation of a fully differentiable boundary element solver for marine hydrodynamics, enabling efficient gradient-based optimization of offshore structures and wave energy converters.</p>
</section>
<section id="authors" class="level2">
<h2 class="anchored" data-anchor-id="authors">Authors</h2>
<ul>
<li><strong>Kapil Khanal</strong> (Cornell University &amp; (partly developed while interning at) Sandia National Laboratories)</li>
<li><strong>Carlos A. Michelén Ströfer</strong> (Sandia National Laboratories)</li>
<li><strong>Matthieu Ancellin</strong> (Eurobios Mews Labs)</li>
<li><strong>Maha Haji</strong> (Cornell University)</li>
</ul>
</section>
<section id="research-highlights" class="level2">
<h2 class="anchored" data-anchor-id="research-highlights">🌟 Research Highlights</h2>
<ul>
<li>📚 <strong>Derivation and discussion</strong> of the discrete adjoint method for the boundary integral equations</li>
<li>💻 <strong>Review and implementation</strong> of a differentiable boundary element solver for marine hydrodynamics in Julia</li>
<li>🌊 <strong>Exact gradient calculation</strong> for a pair of floating hemispheres with respect to their dimensions, separation distance, and wave environment</li>
<li>⚡ <strong>Mechanical power optimization</strong> for a pair of wave energy converters using exact gradients</li>
</ul>
</section>
<section id="about-marinehydro.jl" class="level2">
<h2 class="anchored" data-anchor-id="about-marinehydro.jl">About MarineHydro.jl</h2>
<p><a href="https://github.com/symbiotic-engineering/MarineHydro.jl">MarineHydro.jl</a> is a fully-differentiable boundary element solver for marine hydrodynamics. This new solver implements both direct and indirect boundary element formulations and uses two Green’s function expressions: Wu et al., and Delhommeau’s, varying in their accuracy and speed.</p>
<section id="key-features" class="level3">
<h3 class="anchored" data-anchor-id="key-features">Key Features</h3>
<ul>
<li><strong>Dual Formulation Support</strong>: Implements both direct and indirect boundary element formulations</li>
<li><strong>Multiple Green’s Functions</strong>: Supports Wu et al.&nbsp;and Delhommeau’s Green’s function expressions</li>
<li><strong>Automatic Differentiation</strong>: Fully differentiable with respect to geometry and wave parameters</li>
<li><strong>Julia Implementation</strong>: High-performance implementation in Julia for computational efficiency</li>
<li><strong>Open Source</strong>: MIT licensed and available on GitHub</li>
</ul>
</section>
</section>
<section id="technical-implementation" class="level2">
<h2 class="anchored" data-anchor-id="technical-implementation">Technical Implementation</h2>
<section id="boundary-element-method" class="level3">
<h3 class="anchored" data-anchor-id="boundary-element-method">Boundary Element Method</h3>
<p>The boundary element method (BEM) is particularly well-suited for wave-structure interaction problems because it:</p>
<ul>
<li>Reduces the problem dimensionality by one (surface instead of volume discretization)</li>
<li>Naturally handles infinite domains without artificial boundary conditions</li>
</ul>
</section>
<section id="differentiability-framework" class="level3">
<h3 class="anchored" data-anchor-id="differentiability-framework">Differentiability Framework</h3>
<p>The key innovation in this work is the implementation of automatic differentiation throughout the boundary element solver:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">using</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">MarineHydro</span></span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">using</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">Zygote</span></span>
<span id="cb1-3"></span>
<span id="cb1-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate radiation forces with automatic differentiation</span></span>
<span id="cb1-5">A_w_grad, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Zygote.<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">gradient</span>(w <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">calculate_radiation_forces</span>(mesh, ζ, w)[<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>], ω)</span></code></pre></div>
<p>This enables: - <strong>Exact gradients</strong> without finite difference approximations for the hydrodynamic forces - <strong>Efficient optimization</strong> of complex geometries - <strong>Sensitivity analysis</strong> for design parameters</p>
</section>
<section id="adjoint-method-implementation" class="level3">
<h3 class="anchored" data-anchor-id="adjoint-method-implementation">Adjoint Method Implementation</h3>
<p>The discrete adjoint method is derived and implemented for the boundary integral equations, providing:</p>
<ul>
<li>Computational efficiency for gradient calculations</li>
<li>Scalability to large-scale problems</li>
<li>Integration with modern optimization frameworks</li>
</ul>
</section>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<section id="wave-energy-converters" class="level3">
<h3 class="anchored" data-anchor-id="wave-energy-converters">Wave Energy Converters</h3>
<p>The package demonstrates mechanical power optimization for wave energy converters:</p>
<ul>
<li><strong>Multi-body interactions</strong>: Analysis of arrays of floating bodies</li>
<li><strong>Power optimization</strong>: Maximizing energy extraction efficiency</li>
<li><strong>Geometric sensitivity</strong>: Understanding how shape affects performance</li>
</ul>
</section>
<section id="offshore-structures" class="level3">
<h3 class="anchored" data-anchor-id="offshore-structures">Offshore Structures</h3>
<p>Applications extend to various offshore structures:</p>
<ul>
<li><strong>Floating platforms</strong>: Oil and gas platforms, wind turbines</li>
<li><strong>Marine vessels</strong>: Ships, submarines, underwater vehicles</li>
<li><strong>Coastal structures</strong>: Breakwaters, harbors, piers</li>
</ul>
</section>
</section>
<section id="code-repository" class="level2">
<h2 class="anchored" data-anchor-id="code-repository">Code Repository</h2>
<p>The complete implementation is available at: <a href="https://github.com/symbiotic-engineering/MarineHydro.jl">https://github.com/symbiotic-engineering/MarineHydro.jl</a></p>
<section id="repository-structure" class="level3">
<h3 class="anchored" data-anchor-id="repository-structure">Repository Structure</h3>
<ul>
<li><strong>📁 .github/workflows</strong>: Continuous integration and automated testing</li>
<li><strong>📊 paper</strong>: Plots and data generated for the research paper</li>
<li><strong>📜 src</strong>: Source code for the MarineHydro.jl package</li>
<li><strong>🧪 test</strong>: Comprehensive test suite and validation cases</li>
</ul>
</section>
<section id="getting-started" class="level3">
<h3 class="anchored" data-anchor-id="getting-started">Getting Started</h3>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Clone the repository</span></span>
<span id="cb2-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">git</span> clone https://github.com/symbiotic-engineering/MarineHydro.jl.git</span>
<span id="cb2-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">cd</span> MarineHydro.jl</span>
<span id="cb2-4"></span>
<span id="cb2-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Install dependencies</span></span>
<span id="cb2-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">using</span> Pkg</span>
<span id="cb2-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Pkg.activate</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"."</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">)</span></span>
<span id="cb2-8"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">Pkg.instantiate()</span></span></code></pre></div>
</section>
<section id="basic-usage-example" class="level3">
<h3 class="anchored" data-anchor-id="basic-usage-example">Basic Usage Example</h3>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">using</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">MarineHydro</span></span>
<span id="cb3-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">using</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">PyCall</span></span>
<span id="cb3-3"></span>
<span id="cb3-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Import Capytaine mesh</span></span>
<span id="cb3-5">cpt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">pyimport</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"capytaine"</span>)</span>
<span id="cb3-6">radius <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.0</span></span>
<span id="cb3-7">resolution <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>)</span>
<span id="cb3-8">cptmesh <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cpt.<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">mesh_sphere</span>(name<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"sphere"</span>, radius<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>radius, center<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>), resolution<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>resolution)</span>
<span id="cb3-9">cptmesh.<span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">keep_immersed_part</span>(inplace<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="cn" style="color: #8f5902;
background-color: null;
font-style: inherit;">true</span>)</span>
<span id="cb3-10"></span>
<span id="cb3-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Convert to Julia mesh</span></span>
<span id="cb3-12">mesh <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">Mesh</span>(cptmesh)</span>
<span id="cb3-13"></span>
<span id="cb3-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate diffraction forces</span></span>
<span id="cb3-15">ω <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.03</span></span>
<span id="cb3-16">ζ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># HEAVE motion</span></span>
<span id="cb3-17">F <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">DiffractionForce</span>(mesh, ω, ζ)</span>
<span id="cb3-18"></span>
<span id="cb3-19"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Calculate radiation forces</span></span>
<span id="cb3-20">A, B <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">calculate_radiation_forces</span>(mesh, ζ, ω)</span></code></pre></div>
</section>
</section>
<section id="research-impact" class="level2">
<h2 class="anchored" data-anchor-id="research-impact">Research Impact</h2>
<p>This work addresses several critical challenges in marine hydrodynamics:</p>
<ol type="1">
<li><strong>Computational Efficiency</strong>: Automatic differentiation eliminates the need for expensive finite difference calculations</li>
<li><strong>Design Optimization</strong>: Enables gradient-based optimization of complex marine structures</li>
<li><strong>Multi-physics Integration</strong>: Provides a foundation for coupling with structural and control systems</li>
<li><strong>Open Source Accessibility</strong>: Makes advanced hydrodynamic analysis tools available to the research community</li>
</ol>
</section>
<section id="future-developments" class="level2">
<h2 class="anchored" data-anchor-id="future-developments">Future Developments</h2>
<p>The package is actively developed with plans for:</p>
<ul>
<li><strong>Enhanced API</strong>: More user-friendly interface for complex problems</li>
<li><strong>Performance Optimization</strong>: Further improvements in computational efficiency</li>
<li><strong>Extended Functionality</strong>: Support for additional wave theories and boundary conditions</li>
<li><strong>Documentation</strong>: Comprehensive tutorials and examples</li>
</ul>
</section>
<section id="related-publications" class="level2">
<h2 class="anchored" data-anchor-id="related-publications">Related Publications</h2>
<p>This work is part of a broader research effort in <strong>differentiable programming for engineering applications</strong>. The implementation builds on recent advances in:</p>
<ul>
<li>Automatic differentiation frameworks</li>
<li>Boundary element method theory</li>
<li>Marine hydrodynamics modeling</li>
<li>Optimization algorithms</li>
</ul>
<hr>
<p><em>MarineHydro.jl represents a significant step forward in making advanced hydrodynamic analysis accessible for design optimization, enabling researchers and engineers to efficiently explore the design space for marine structures and wave energy devices.</em></p>


</section>

 ]]></description>
  <category>software</category>
  <category>research</category>
  <category>Julia</category>
  <category>hydrodynamics</category>
  <category>optimization</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/marinehydro-julia-package/</guid>
  <pubDate>Sun, 22 Jun 2025 00:00:00 GMT</pubDate>
  <media:content url="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/marinehydro-julia-package/julia_dots.png" medium="image" type="image/png" height="144" width="144"/>
</item>
<item>
  <title>Coupled Multidisciplinary Multiobjective Systems: Searching for Similarly Performing System Designs</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/aiaa-scitech-2026-submission/</link>
  <description><![CDATA[ 




<section id="conference-information" class="level2">
<h2 class="anchored" data-anchor-id="conference-information">Conference Information</h2>
<p><strong>2026 AIAA SciTech Forum</strong><br>
<strong>12–16 January 2026</strong><br>
<strong>Hyatt Regency Orlando</strong><br>
<strong>Orlando, Florida</strong></p>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>In many practical settings, mathematically optimal system designs are often set aside in favor of similarly performing alternatives that better accommodate real-world constraints and evolving requirements. In such cases, it is desirable to identify alternative design vectors that maintain acceptable levels of system performance. This can be achieved using isoperformance method, which construct sets of performance-invariant solutions, or through multiobjective optimization. However, traditional isoperformance approaches typically ignore the feasibility constraints that arise in coupled systems governed by multidisciplinary analysis (MDA). These systems require convergence of nonlinear solvers, and the resulting computational burden increases when newly generated designs do not satisfy such feasibility inherently. Isoperformance analysis is an inverse design technique used to identify a set of feasible design vectors that yield a specified vector of system performance metrics. This performance-invariant set provides a space for subsequent decision-making based on secondary criteria like cost, risk, or implementation ease. However, applying isoperformance methods to complex coupled systems is challenging, as these systems often require a multidisciplinary analysis (MDA) to resolve interdependencies among components. The resulting nonlinear solver demands increase computational cost when infeasible designs are evaluated.</p>
<p>In this paper, we propose two contributions to improve the robustness and scalability of isoperformance methods in such settings. First, we extend the isoperformance method to support arbitrarily large design spaces using reverse-mode automatic differentiation and adjoint sensitivity analysis. Second, we introduce a regularized isoperformance approach that incorporates the feasibility constraints arising from MDA directly into the Jacobian, improving the likelihood of convergence and solution quality. We demonstrate the method on a benchmark coupled problem involving three objectives, showcasing its ability to generate feasible isoperformant designs. decision-making in complex engineered systems requires balancing conflicting objectives among various subsystems and stakeholders. In many cases, a numerically optimal solution is not the final adopted design due to constraints, trade-offs, or the infeasibility of implementation. This motivates the search for alternative design solutions that achieve target performance levels without requiring complete re-optimization.</p>
<p>To address this, we enhance the isoperformance approach to explicitly consider MDA feasibility during inverse design. This is critical for large systems where convergence, sensitivity, and robustness all play significant roles in engineering decision-making.</p>
</section>
<section id="authors" class="level2">
<h2 class="anchored" data-anchor-id="authors">Authors</h2>
<ul>
<li><strong>Kapil Khanal</strong> (PhD Candidate, Systems Engineering)</li>
<li><strong>Maha N. Haji</strong> (Assistant Professor, Sibley School of Mechanical Engineering)</li>
</ul>
<p><strong>Affiliation</strong>: Cornell University, Ithaca, NY</p>
</section>
<section id="research-context" class="level2">
<h2 class="anchored" data-anchor-id="research-context">Research Context</h2>
<p>This work addresses a fundamental challenge in multidisciplinary design optimization (MDO): the gap between mathematically optimal solutions and practically implementable designs. While optimization algorithms can find the “best” solution according to mathematical criteria, real-world engineering often requires flexibility in design choices to accommodate:</p>
<ul>
<li>Manufacturing constraints</li>
<li>Supply chain limitations<br>
</li>
<li>Regulatory requirements</li>
<li>Future design modifications</li>
<li>Risk mitigation strategies</li>
</ul>
<p>The isoperformance method offers a systematic approach to explore the design space for alternatives that maintain acceptable performance levels while providing the flexibility needed for practical implementation.</p>
</section>
<section id="key-contributions" class="level2">
<h2 class="anchored" data-anchor-id="key-contributions">Key Contributions</h2>
<section id="scalable-isoperformance-with-automatic-differentiation" class="level3">
<h3 class="anchored" data-anchor-id="scalable-isoperformance-with-automatic-differentiation">1. Scalable Isoperformance with Automatic Differentiation</h3>
<p>Traditional isoperformance methods often struggle with high-dimensional design spaces due to computational limitations in gradient computation. Our approach leverages:</p>
<ul>
<li><strong>Reverse-mode automatic differentiation</strong> for efficient gradient computation.</li>
</ul>
<p>This enables the method to scale to arbitrarily large design spaces while maintaining computational efficiency.</p>
</section>
<section id="regularized-isoperformance-for-coupled-systems" class="level3">
<h3 class="anchored" data-anchor-id="regularized-isoperformance-for-coupled-systems">2. Regularized Isoperformance for Coupled Systems</h3>
<p>Coupled multidisciplinary systems introduce unique challenges through:</p>
<ul>
<li><strong>Nonlinear coupling constraints</strong> between disciplines</li>
<li><strong>Feasibility requirements</strong> that must be satisfied simultaneously</li>
<li><strong>Convergence dependencies</strong> of numerical solvers</li>
</ul>
</section>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<p>This work has broad applications across engineering disciplines, including:</p>
<ul>
<li><strong>Aerospace Systems</strong>: Aircraft design with multiple performance objectives</li>
<li><strong>Marine Engineering</strong>: Offshore structure optimization under environmental constraints</li>
<li><strong>Energy Systems</strong>: Renewable energy device design and optimization</li>
<li><strong>Transportation</strong>: Vehicle design balancing performance, efficiency, and safety</li>
</ul>
<p><em>This work represents a significant step forward in making optimization methods more practical and accessible for complex engineering systems, bridging the gap between mathematical optimality and engineering feasibility.</em></p>


</section>

 ]]></description>
  <category>conference</category>
  <category>MDO</category>
  <category>optimization</category>
  <category>research</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/aiaa-scitech-2026-submission/</guid>
  <pubDate>Tue, 22 Apr 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Enhancing the Boundary Element Method with Scientific Machine Learning</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/neural-networks-bem/</link>
  <description><![CDATA[ 




<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The Boundary Element Method (BEM) is a cornerstone of computational hydrodynamics, widely used to solve the three-dimensional diffraction-radiation problem for floating bodies. BEM involves transforming a partial differential equation (PDE) into a boundary integral equation using Green’s theorem, which is then solved numerically. A key challenge in BEM is the numerical evaluation of the Green’s function, particularly its wave-related terms. These computations typically scale poorly, often at <img src="https://latex.codecogs.com/png.latex?O(N%5E3)"> with the number of panels (<img src="https://latex.codecogs.com/png.latex?N">), creating a significant bottleneck. This is especially problematic in large-scale optimization tasks for offshore structures, which involve many panels and design parameters.</p>
<p>This creates a classic trade-off: <strong>accuracy vs.&nbsp;efficiency</strong>. We propose adding a third dimension to this trade-off: <strong>the ease of numerical differentiation</strong>. While surrogate models and semi-analytical methods exist, we introduce a hybrid approach that leverages a <strong>physics-informed neural network (PINN)</strong> to enhance the traditional BEM program.</p>
</section>
<section id="neural-networks-in-scientific-machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="neural-networks-in-scientific-machine-learning">Neural Networks in Scientific Machine Learning</h2>
<p>The classical expression of the free surface Greens function.<img src="https://latex.codecogs.com/png.latex?G(P,Q)%20=%20%5Ctext%7Bfundamental%20solution%7D%20+%20%5Ctextit%7Bharmonic%20function%7D"> : <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Bequation%7D%0AG(P,Q)%20=%20%5Cleft(%5Cfrac%7B1%7D%7BX%5E2+%20(Z_1-Z_2)%5E2%7D%5Cright)%20+%20%5Cleft(%20%5Cfrac%7B1%7D%7BX%5E2+%20Y%5E2%7D%20+%20F(X,Y)%0A+%202%20%5Cpi%20ik_0%20e%5E%7B-Y%7D%20J_0(X)%5Cright)%20%20%0A%5Cend%7Bequation%7D"> where horizontal (X) and vertical distances (Y), \ <img src="https://latex.codecogs.com/png.latex?X:k_0%20*%5Csqrt%7Bx1-x2)%5E2%20%20+%20(y1-y2)%5E2%7D"> and <img src="https://latex.codecogs.com/png.latex?Y:-k_o(z1+z2)"> Newman simplified <img src="https://latex.codecogs.com/png.latex?F(X,Y)"> from the original expression (not included here) which has many computational challenges to: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Bequation%7D%0AF(X,%20Y)%20=%20-2e%5E%7B-y%7D%20%5Cint_%7B0%7D%5E%7BY%7D%20%5Cfrac%7Be%5Et%7D%7B%5Csqrt%7BX%5E2%20+%20t%5E2%7D%7D%20%5C,%20dt%20-%20%5Cpi%20e%5E%7B-y%7D%20%5Cleft%5BB(X)%20+%20H(X)%5Cright%5D%0A%5Cend%7Bequation%7D"></p>
<p>Q: Can we instead use a neural network to approximate the Green’s function?</p>
<p>Neural networks have a growing history in scientific machine learning, with recent publications demonstrating their power in hydrodynamics . However, a well-known challenge is that standard neural networks often struggle to learn periodic and oscillatory functions, which are fundamental to wave physics.</p>
<p>Several research avenues have explored solutions to this, including: - Transforming data into the Fourier space. - Developing novel activation functions. - Using deeper network architectures.</p>
<p>We’re exploring the use of neural networks to approximate the Green’s function and integrate it into our in-house BEM solver - <a href="https://github.com/symbiotic-engineering/MarineHydro.jl">MarineHydro.jl</a>.</p>
<p><strong>This is a work in progress.</strong></p>
<!-- ## Model Architecture

We use a fully connected neural network with a `[2, 30, 30, 30, 30, 30, 30, 30, 1]` architecture (input, hidden layers, output). While deeper networks can improve generalization, they also increase inference time, creating a trade-off between model performance and speed.


![Neural Network Architecture](nn.png)

To better capture the oscillatory nature of the problem, we adopt two specialized activation functions:
1.  **Trainable Rational Activation Function**: Used for most hidden layers.
2.  **Oscillatory Activation Function**: $x + \sin^2(x)$, used for the final hidden layer.

Computational experiments suggest this combination yields the best performance. The rational activation function is defined as:

$$
F(x) = \frac{\sum_{i=0}^{r_p}a_i x^i}{\sum_{j=0}^{r_q}b_j x^j}, \quad a_{r_p} \neq 0, b_{r_q} \neq 0
$$

This neural network-based global approximation aims to be as fast as older, less accurate methods (like Wu et al.'s approximation) while being as accurate as more modern, computationally intensive ones (like Newman's derivation), all while generalizing well to domains outside the training data.

## Loss Function: A Physics-Informed Approach

A key to successfully training a network on a physical problem is to inform it about the underlying physics. Since the terms of the Green's function satisfy the Laplace equation, we can build this constraint directly into the loss function. Specifically, we enforce the following condition:

$$
\nabla^2 F = \frac{1}{X} \frac{\partial F}{\partial X}  + \frac{\partial^2 F}{\partial Y^2} + \frac{\partial^2 F}{\partial X^2} = 0
$$ -->
<!-- Our loss function penalizes not only incorrect predicted values but also **incorrect gradients**. We use automatic differentiation to compute the gradients of the network's output with respect to its inputs ($\nabla_X \hat{NN}, \nabla_Y \hat{NN}$) and include a term in the loss that pushes these gradients to satisfy the Laplace equation. This ensures the model learns solutions that are not just accurate but also physically consistent. -->
<hr>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<ul>
<li>John, F. (1950). On the motion of floating bodies II. <em>Communications on Pure and Applied Mathematics</em>.</li>
<li>Xie, M., et al.&nbsp;(2018). A review of Green’s functions for marine hydrodynamics. <em>Journal of Hydrodynamics</em>.</li>
<li>Huang, G., et al.&nbsp;(2022). Deep-learning-based fast-prediction method for hydrodynamic performance of a ship sailing in waves. <em>Ocean Engineering</em>.</li>
<li>Zhan, S., et al.&nbsp;(2023). A review of deep learning in naval architecture and ocean engineering. <em>Ocean Engineering</em>.</li>
<li>Boulle, N., et al.&nbsp;(2020). Rational neural networks. <em>arXiv preprint</em>.</li>
</ul>


</section>
</section>

 ]]></description>
  <category>research</category>
  <category>machine learning</category>
  <category>hydrodynamics</category>
  <category>Julia</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/neural-networks-bem/</guid>
  <pubDate>Tue, 30 Jul 2024 00:00:00 GMT</pubDate>
  <media:content url="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/neural-networks-bem/nn.png" medium="image" type="image/png" height="103" width="144"/>
</item>
<item>
  <title>Differentiable Wave-to-Wire Model for Wave Energy Converter Optimization</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/idetc-2025-submission/</link>
  <description><![CDATA[ 




<p>I recently submitted a paper to the <strong>ASME 2025 International Design Engineering Technical Conferences &amp; Computers and Information in Engineering Conference (IDETC/CIE)</strong>, to be held in Anahiem, California, from August 17-20, 2025.</p>
<p>Below is the abstract for the submission.</p>
<hr>
<section id="abstract" class="level3">
<h3 class="anchored" data-anchor-id="abstract">Abstract</h3>
<p>Wave energy conversion requires optimal design and control strategies to maximize energy extraction. Optimization approaches such as control co-design optimize plant design and the control strategies together. Several existing approaches use heuristic methods that do not scale well with high-dimensional design spaces. A gradient-based approach scales better than the heuristic method, for which the integrated model should be able to provide not just the output but its sensitivity with respect to the inputs. Currently, these different numerical solvers are used in isolation, thus making heuristic optimizers a natural choice.</p>
<p>This study develops a <strong>differentiable model</strong> integrating boundary element methods (BEM) for hydrodynamic modeling with <strong>pseudo-spectral optimal control</strong> techniques to optimize power take-off (PTO) forces under dynamic constraints for maximizing electrical power per volume of a point absorber wave energy converter (WEC). This model is useful for the large-scale gradient-based optimization of the electrical power.</p>
<p>Discussion and derivation of the <strong>semi-analytic adjoint for the hydrodynamics solver</strong>, non-linear parametric sensitivity for the trajectory optimization, and the calculation of the coupled derivative using unified derivative equations is presented. A nested formulation of the control co-design approach within a multidisciplinary design optimization architecture is created for the differentiable wave-to-wire model. Preliminary numerical experiment and verification of the sensitivities is conducted for the differentiable wave-to-wire model for a heaving point absorber WEC.</p>


</section>

 ]]></description>
  <category>conference</category>
  <category>research</category>
  <category>optimization</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/idetc-2025-submission/</guid>
  <pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
  <media:content url="https://github.com/KapilKhanal/kapilkhanal.github.io/files/images/placeholder3.JPG" medium="image"/>
</item>
<item>
  <title>Gradient-Based Optimization for Large Systems</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/gradient-based-optimization/</link>
  <description><![CDATA[ 




<section id="multidisciplinary-design-optimization-architecture" class="level2">
<h2 class="anchored" data-anchor-id="multidisciplinary-design-optimization-architecture">Multidisciplinary Design Optimization Architecture</h2>
<p>A computational architecture for Multidisciplinary Design Optimization (MDO) is composed of three primary components: <strong>solvers</strong> (e.g., Newton), <strong>simulators</strong> (or emulators, PDE solvers, closed-form expressions), and <strong>optimizers</strong> (e.g., IPOPT, Genetic Algorithm). The performance and efficiency of the overall system are directly influenced by the selection and interaction of these components.</p>
<p>Simulators and solvers are required to either compute the performance of the system through some physics (numerical simulation) or resolve non-linear feedback coupling between subsystems (non-linear equation solvers). A system where all the subsystems agree on their input and output (including any shared variables) is necessary for the system to be optimal and feasible. The coordination of the variables can, however, be done in numerous ways that involve solvers and/or optimizers. Many architectures that arise due to these choices are briefly discussed in later sections.</p>
<p>For offshore systems, marine hydrodynamics solvers (like the boundary element method) are required. The choice of solvers, however, depends on the strength of the coupling between two subsystems. In this post, a Newton solver is used to converge the feedback coupling when necessary.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/gradient-based-optimization/coupled_uncoupled.png" class="img-fluid figure-img"></p>
<figcaption>Large systems</figcaption>
</figure>
</div>
<section id="mdo-stack" class="level3">
<h3 class="anchored" data-anchor-id="mdo-stack">MDO ‘Stack’</h3>
<p>The MDO system can be represented as a set:</p>
<p><img src="https://latex.codecogs.com/png.latex?F:%5C%7B%5Cmathcal%7BO%7D,%20%5Cmathcal%7BM%7D,%20%5Cmathcal%7BS%7D%5C%7D"></p>
<p>where <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BM%7D"> is the set of simulators, <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D"> is the choice of optimizer, and <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BS%7D"> is the set of solvers.</p>
<p>The performance <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D(%5Cmathcal%7BF%7D)"> depends on:</p>
<ul>
<li>The compatibility of <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BM%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BS%7D"> with <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D">.</li>
<li>The computational efficiency of <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BF%7D">, defined by the time <img src="https://latex.codecogs.com/png.latex?T(%5Cmathcal%7BF%7D)"> and accuracy <img src="https://latex.codecogs.com/png.latex?A(%5Cmathcal%7BF%7D)">.</li>
<li>The convergence of the optimization problem.</li>
</ul>
<p>Gradient-based optimizers (<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D_%7B%5Cnabla%7D">) achieve superior performance (<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BP%7D(%5Cmathcal%7BF%7D_%7B%5Cnabla%7D)%20%3E%20%5Cmathcal%7BP%7D(%5Cmathcal%7BF%7D_%7B%5Cneg%20%5Cnabla%7D)">) when <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BM%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BS%7D"> are differentiable. However, the practical challenges of computing gradients for certain simulators and solvers remain a significant limitation.</p>
</section>
<section id="choice-of-optimizer" class="level3">
<h3 class="anchored" data-anchor-id="choice-of-optimizer">Choice of Optimizer</h3>
<p>Let <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BF%7D"> represent the multidisciplinary optimization problem, where each problem <img src="https://latex.codecogs.com/png.latex?p%20%5Cin%20%5Cmathcal%7BF%7D"> is defined by a set of variables (design, shared, target), constraints (including consistency constraints), and objectives (one or many). The optimizer is a function <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D:%20%5Cmathcal%7BF%7D%20%5Cto%20%5Cmathcal%7BR%7D">, where <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BR%7D"> is the space of feasible solutions.</p>
<p>Optimizers commonly used in MDO problems can be broadly categorized into:</p>
<ol type="1">
<li><strong>Gradient-Based Optimizers</strong> (<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D_%7B%5Cnabla%7D">): These optimizers leverage the gradient <img src="https://latex.codecogs.com/png.latex?%5Cnabla%20f"> of the objective function <img src="https://latex.codecogs.com/png.latex?f"> to iteratively find a minimum. The preference for gradient-based methods arises from their superior convergence speed when gradients are available and computationally inexpensive. However, obtaining gradients can be challenging:
<ul>
<li>Certain simulator software <img src="https://latex.codecogs.com/png.latex?S:%20%5Cmathcal%7BX%7D%20%5Cto%20%5Cmathcal%7BY%7D">, where <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BX%7D"> is the input space and <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BY%7D"> is the output space, may not inherently provide differentiable mappings.</li>
<li>Numerical approximations such as finite differences (<img src="https://latex.codecogs.com/png.latex?%5Cnabla%20f%20%5Capprox%20%5Cfrac%7B%5CDelta%20f%7D%7B%5CDelta%20x%7D">) may introduce errors and computational overhead when differentiating this class of simulators.</li>
</ul></li>
<li><strong>Gradient-Free Optimizers</strong> (<img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D_%7B%5Cneg%20%5Cnabla%7D">): These include evolutionary algorithms and heuristic methods that do not require gradient information. Evolutionary strategies are stochastic and derivative-free. While easier to use and robust for non-differentiable problems (think black-box type problems), they often lack the efficiency of <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BO%7D_%7B%5Cnabla%7D"> for high-dimensional spaces.</li>
</ol>
</section>
<section id="choice-of-solvers-and-simulators" class="level3">
<h3 class="anchored" data-anchor-id="choice-of-solvers-and-simulators">Choice of Solvers and Simulators</h3>
<p><img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BS%7D"> is the set of solvers and <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BM%7D"> is the set of simulators needed for the MDO problems. The choices <img src="https://latex.codecogs.com/png.latex?s%20%5Cin%20%5Cmathcal%7BS%7D"> and <img src="https://latex.codecogs.com/png.latex?m%20%5Cin%20%5Cmathcal%7BM%7D"> affect the feasibility and convergence of the optimization problem. For instance:</p>
<ul>
<li>A simulator <img src="https://latex.codecogs.com/png.latex?m"> that provides closed-form solutions is often preferable for gradient-based methods because of the ease of differentiating symbolic expressions. This, however, often means that a lower-fidelity model of the physics is used.</li>
<li>A solver <img src="https://latex.codecogs.com/png.latex?s"> is usually selected for its ability to resolve non-linear coupling. A differentiation of the solver algorithm is not needed; only the derivative at the solution of the solver is needed, which is obtained using implicit differentiation.</li>
</ul>
<p>A robust and widely adopted method for calculating gradients in numerical code is <strong>differentiable programming</strong>, where automatic differentiation is commonly used.</p>
<p>Starting with the PDE of a physical process, many frameworks can be used. If the system includes only one discipline, a relevant simulation or PDE code can be used on its own. If there are multiple disciplines, then either a joint discretization of that PDE (e.g., using FEM) is needed, or a way to couple them together if such a joint discretization is complicated or unavailable. Commercial finite element frameworks (like COMSOL Multiphysics) are robust for many coupled physics problems, such as aero-structural interactions.</p>
<p>However, when there is a need to couple a diverse set of numerical codes—such as a boundary element method or an explicit equation coupled with other disciplines—such unified frameworks are limited. A framework where a heterogeneous set of solvers can be used in a plug-and-play style is highly desirable. This also avoids the need for new discretizations of the coupled problem if the system model has additional subsystems or if the fidelity of a simulation changes. This post advocates to adopt this modular architecture approach where any <img src="https://latex.codecogs.com/png.latex?s%20%5Cin%20%5Cmathcal%7BS%7D"> can be easily used.</p>
</section>
<section id="computational-graph-and-unified-derivative-equation" class="level3">
<h3 class="anchored" data-anchor-id="computational-graph-and-unified-derivative-equation">Computational Graph and Unified Derivative Equation</h3>
<p>Multiple fields independently concluded that gradient-based methods scale well and utilized adjoint-based optimization. Backpropagation, as discussed by LeCun et al., shows the connection between optimal control and <span style="color: #B31B1B;"><strong>neural networks</strong></span> and how backpropagating errors scales the training of <span style="color: #B31B1B;"><strong>neural nets</strong></span>.</p>
<p>Design optimization in complex engineering systems, from neural networks to physical structures, encounters two principal challenges:</p>
<ol type="1">
<li><strong>Large Number of Design Variables</strong>: These systems involve numerous “knobs” to tune—such as weights and biases in neural networks or geometric and material properties in physical systems.</li>
<li><strong>High Computational Cost</strong>: The computation required to evaluate these systems often lacks scalability, creating a bottleneck.</li>
</ol>
<section id="neural-networks-vs.-physical-systems" class="level4">
<h4 class="anchored" data-anchor-id="neural-networks-vs.-physical-systems">Neural Networks vs.&nbsp;Physical Systems</h4>
<ul>
<li><strong>Neural Networks</strong>: The core computation involves evaluating affine transformations followed by nonlinear activation functions. These operations must be performed billions of times during training. The sheer volume of operations makes scaling these systems challenging, despite the simplicity of individual computations.</li>
<li><strong>Physical Systems</strong>: Optimizing systems like airplanes or offshore wind turbines introduces a different complexity. These designs involve thousands of variables, each influencing coupled physics simulations (CFD, structural mechanics, etc.). Each simulation is computationally expensive, making the design process resource-intensive.</li>
</ul>
<p>To overcome these challenges, reviewing the literature from both fields reveals that <strong>adjoint-based methods</strong> are widely utilized. However, each discipline has optimized gradient computation to suit its specific tasks. In machine learning, computational graphs are a common framework for implementing backpropagation using dynamic programming and the chain rule. In MDO, the same objective is achieved by solving a linear system, where backpropagation can be viewed as a special case that employs linear solvers to solve that system efficiently. The work of LeCun, Hwang, and Martins and others has helped unify these approaches, showing how various methods like automatic differentiation (AD) and adjoint methods can be derived from a single cohesive formulation by viewing any system as a non-linear system and utilizing the implicit function theorem.</p>
<p>In this post, I discussed how two different fields, machine learning and MDO, have converged on the same approach to scale the system optimization using gradients.</p>
<!-- ### MDO Architectures for Offshore Systems

A comparison between monolithic and distributed optimization architectures is performed in this section. Among many, the two most common architectures, Multidisciplinary Feasible (MDF) and Collaborative Optimization (CO), are used to showcase how these architectures could be adopted for the design optimization of offshore structures.  -->


</section>
</section>
</section>

 ]]></description>
  <category>MDO</category>
  <category>optimization</category>
  <category>research</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/gradient-based-optimization/</guid>
  <pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>A Differentiable Framework for Multidisciplinary Design Optimization of Novel Offshore Systems</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/differentiable-hydrodynamics-framework/</link>
  <description><![CDATA[ 




<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Optimizing the levelized cost of electricity for floating offshore wind turbines (FOWTs) and wave energy parks involves analyzing multiple coupled subsystems including geometry, aerodynamics, and hydrodynamics. In complex engineered systems, the solution of governing equations in one subsystem changes the input for another subsystem. As the saying goes in engineering: “everything influences everything else” <span class="citation" data-cites="mdo_1993">(Sobieszczanski-Sobieski and Haftka 1993)</span>. This creates design tradeoffs between several subsystems, necessitating an integrated multidisciplinary analysis approach.</p>
<p><strong>Multidisciplinary Design Optimization (MDO)</strong> is a field of engineering that focuses on using numerical optimization and solvers for designing systems involving multiple coupled disciplines or subsystems <span class="citation" data-cites="mdobook">(Martins and Lambe 2013)</span>. Research has shown that sequential optimization of coupled subsystems usually results in sub-optimal designs, while an MDO approach leads to system-optimal solutions <span class="citation" data-cites="mdo_1993">(Sobieszczanski-Sobieski and Haftka 1993)</span>.</p>
</section>
<section id="motivation-for-a-differentiable-framework" class="level2">
<h2 class="anchored" data-anchor-id="motivation-for-a-differentiable-framework">Motivation for a Differentiable Framework</h2>
<p>Offshore and marine energy systems are inherently complex coupled systems. Currently, no integrated framework exists for offshore structures that supports both hydrodynamic simulation and shape optimization. This represents a significant bottleneck for design studies and optimization efforts. The adoption of MDO-based approaches should be encouraged to increase accessibility for further research <span class="citation" data-cites="roadmapNREL">(Musial et al. 2020)</span>.</p>
<p>In multidisciplinary design optimization, changes in one subsystem propagate across other subsystems. For example, a change in the mean position of a floating body alters the waterline and waterplane area, requiring recalculation of hydrodynamic coefficients. Similarly, research on novel multipurpose platforms <span class="citation" data-cites="Multipurpose">(Perez-Collazo, Greaves, and Iglesias 2015)</span> would benefit from such a framework.</p>
<p>The framework I’m developing is intended to serve as: - A tool for early design studies in the conceptual phase - A plugin for other MDO applications where hydrodynamics analysis is coupled</p>
</section>
<section id="multidisciplinary-design-optimization" class="level2">
<h2 class="anchored" data-anchor-id="multidisciplinary-design-optimization">Multidisciplinary Design Optimization</h2>
<section id="hydrodynamic-shape-optimization" class="level3">
<h3 class="anchored" data-anchor-id="hydrodynamic-shape-optimization">Hydrodynamic Shape Optimization</h3>
<p>MDO of offshore structures involves shape perturbation and optimization. Different underwater shapes of floating bodies respond differently to incoming ocean waves, making shape optimization crucial for offshore platform design.</p>
<p>Offshore structures like spar buoys (vertical cylindrical structures) can be reasonably modeled using analytical approximations <span class="citation" data-cites="Haghi_2014 morison_force_1950">(Haghi, Sabbagh-Yazdi, and Ghalandari 2014; Morison, Johnson, and Schaaf 1950)</span>. However, these analytical approaches are not feasible for non-standard geometries—those obtained after perturbing a base shape, usually described using splines. Efficient shape parameterization and numerical solvers explore the design space much better <span class="citation" data-cites="mdobook">(Martins and Lambe 2013)</span>. In MDO, shapes are typically perturbed to be compatible with other subsystems, with B-splines (CAD geometry) being preferred <span class="citation" data-cites="Samareh_2001">(Samareh 2001)</span>.</p>
<p>The response motion of offshore structures is calculated using hydrodynamic coefficients such as added mass and damping. These coefficients characterize the geometry of floating structures. A transfer function called the <strong>Response Amplitude Operator (RAO)</strong> linearly relates sea motion to floating body motion.</p>
</section>
</section>
<section id="boundary-element-method" class="level2">
<h2 class="anchored" data-anchor-id="boundary-element-method">Boundary Element Method</h2>
<p><strong>Boundary Element Methods (BEM)</strong> are used to calculate hydrodynamic coefficients, relying on linear potential flow theory where the exact Green’s function and its derivative are known <span class="citation" data-cites="BEMcomparison">(Babarit and Delhommeau 2011)</span>. BEM-based PDE solvers <span class="citation" data-cites="babarit_theoretical_2015">(Babarit 2015)</span> are typically accurate for most geometries and can be coupled for shape optimization within a design framework. Depending on system requirements, we may want to minimize or maximize body response to waves—minimizing motion for wind turbines while maximizing motion for wave energy converters.</p>
<p>Hydrodynamics of floating bodies is typically modeled using linear potential flow theory. Since the domain is unbounded, boundary element methods are used, requiring only boundary discretization—the surface geometry is meshed with quadrilateral panels.</p>
<p>For each frequency of ocean waves the structure encounters, diffraction and radiation problems are solved to calculate hydrodynamic coefficients. The solution of velocity potential and radiation/diffraction forces is computed in the frequency domain.</p>
<p>Computational cost increases with geometry discretization and the number of wave frequencies and headings. Typically, numerical complexity of BEM codes is proportional to <img src="https://latex.codecogs.com/png.latex?O(N%5E2)"> or <img src="https://latex.codecogs.com/png.latex?O(N%5E3)"> with <img src="https://latex.codecogs.com/png.latex?N"> as the number of mesh panels. The Green function is computed <img src="https://latex.codecogs.com/png.latex?O(N%5E2)"> times to set up the linear system, which is solved either by iterative methods with <img src="https://latex.codecogs.com/png.latex?O(N%5E2)"> complexity or Gauss elimination with <img src="https://latex.codecogs.com/png.latex?O(N%5E3)"> complexity <span class="citation" data-cites="BEMcomparison">(Babarit and Delhommeau 2011)</span>.</p>
<p>This limits integration within optimization loops, especially for large-scale optimization based on heuristic methods. The solution is to minimize function evaluations in optimization. Gradient-based optimization explores design space more efficiently (fewer evaluations) to reach locally optimal points</p>
<section id="differentiable-hydrodynamics" class="level3">
<h3 class="anchored" data-anchor-id="differentiable-hydrodynamics">Differentiable Hydrodynamics</h3>
<p>Coupling numerical solvers within optimization is computationally costly. Shape optimization with many design variables requires an efficient way to calculate both the response and its gradient. Researchers often rely on reduced-order models to approximate hydrodynamic response and heuristic methods for optimization. However, heuristic methods don’t scale well for large-scale optimization, and reduced-order models lack the accuracy of full simulations.</p>
<p><strong>Gradient-based optimization</strong> is preferred for large-scale optimization with many design variables and costly function evaluations. Coupling numerical solvers in gradient-based optimization requires gradients of solver output with respect to all inputs. While this has been implemented for CFD <span class="citation" data-cites="DAFoam">(He et al. 2020)</span>, no implementation of <strong>differentiable hydrodynamics</strong> (differentiable BEM) exists.</p>
<p>Among various gradient calculation methods, <strong>adjoint-based methods</strong> are accurate and efficient for inverse design problems. Adjoint methods are widely used in optimal control and aerodynamic shape optimization <span class="citation" data-cites="jameson">(Jameson 1988)</span> as well as design optimization <span class="citation" data-cites="Adjoint_intro">(Giles and Pierce 2000)</span>, but haven’t been applied to BEM-based hydrodynamics shape optimization.</p>
</section>
<section id="coupled-derivatives" class="level3">
<h3 class="anchored" data-anchor-id="coupled-derivatives">Coupled Derivatives</h3>
<p>For multidisciplinary design optimization, <strong>Modular Analysis and Unified Derivatives (MAUD)</strong> architecture couples derivatives from several subsystems. MAUD formulates the multidisciplinary model as a nonlinear system of equations, leading to a linear equation that unifies all derivative computation methods <span class="citation" data-cites="maud">(Hwang and Martins 2018)</span>. Each subsystem can provide numerical or analytical gradients.</p>
<p><strong>OpenMDAO</strong> <span class="citation" data-cites="Gray2019a">(Gray et al. 2019)</span>, a tool developed by NASA, implements this framework. I plan to integrate newly developed BEM adjoints into this framework. Currently, I integrate BEM in OpenMDAO using numerical derivatives approximated through finite differences <span class="citation" data-cites="novelOpenMDAO">(Khanal and Haji 2023)</span>. Since this scales linearly with the number of design variables and accuracy deteriorates for nonlinear problems, it’s not appropriate for multidisciplinary analysis and optimization. My thesis aims to solve this problem.</p>
<section id="understanding-adjoint-methods" class="level4">
<h4 class="anchored" data-anchor-id="understanding-adjoint-methods">Understanding Adjoint Methods</h4>
<p>Adjoint methods provide an elegant way to compute gradients of objective functions with respect to many design variables at a computational cost that is essentially independent of the number of design variables. This is particularly valuable for shape optimization problems where we may have hundreds or thousands of design variables.</p>
<p><strong>The key insight</strong> of adjoint methods is that instead of computing <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20%5Ctheta%7D"> directly (which would require solving the system for each design variable), we solve a single adjoint equation to obtain the sensitivity of the objective function.</p>
<p>For our BEM optimization problem:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%0A%5Cmin_%7B%5Ctheta,x%7D%20%5Cquad%20&amp;%20J(S(%5Ctheta),%20x(%5Ctheta);%20%5Ctheta%20)%20%5C%5C%0A%5Ctextrm%7Bs.t.%7D%20%5Cquad%20R(%5Ctheta)=%20%20&amp;%20K(%5Ctheta)%5Ctimes%20x(%5Ctheta)%20-%20B(%5Ctheta)%20=%200%20%5C%5C%0A%5Cend%7Baligned%7D"></p>
<p>The total derivative of the objective function with respect to design variables is:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7BdJ%7D%7Bd%5Ctheta%7D%20=%20%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Ctheta%7D%20+%20%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20x%7D%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20%5Ctheta%7D"></p>
<p>Using the constraint equation <img src="https://latex.codecogs.com/png.latex?R(%5Ctheta)%20=%20K(%5Ctheta)x(%5Ctheta)%20-%20B(%5Ctheta)%20=%200">, we can derive:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20R%7D%7B%5Cpartial%20%5Ctheta%7D%20=%20%5Cfrac%7B%5Cpartial%20K%7D%7B%5Cpartial%20%5Ctheta%7Dx%20+%20K%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20%5Ctheta%7D%20-%20%5Cfrac%7B%5Cpartial%20B%7D%7B%5Cpartial%20%5Ctheta%7D%20=%200"></p>
<p>Solving for <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20%5Ctheta%7D">:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20%5Ctheta%7D%20=%20K%5E%7B-1%7D%5Cleft(%5Cfrac%7B%5Cpartial%20B%7D%7B%5Cpartial%20%5Ctheta%7D%20-%20%5Cfrac%7B%5Cpartial%20K%7D%7B%5Cpartial%20%5Ctheta%7Dx%5Cright)"></p>
<p>Substituting back into the total derivative:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7BdJ%7D%7Bd%5Ctheta%7D%20=%20%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Ctheta%7D%20+%20%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20x%7DK%5E%7B-1%7D%5Cleft(%5Cfrac%7B%5Cpartial%20B%7D%7B%5Cpartial%20%5Ctheta%7D%20-%20%5Cfrac%7B%5Cpartial%20K%7D%7B%5Cpartial%20%5Ctheta%7Dx%5Cright)"></p>
<p><strong>The adjoint variable</strong> <img src="https://latex.codecogs.com/png.latex?%5Clambda"> is defined as the solution to:</p>
<p><img src="https://latex.codecogs.com/png.latex?K%5ET%5Clambda%20=%20%5Cleft(%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20x%7D%5Cright)%5ET"></p>
<p>This leads to the elegant expression:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7BdJ%7D%7Bd%5Ctheta%7D%20=%20%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Ctheta%7D%20+%20%5Clambda%5ET%5Cleft(%5Cfrac%7B%5Cpartial%20B%7D%7B%5Cpartial%20%5Ctheta%7D%20-%20%5Cfrac%7B%5Cpartial%20K%7D%7B%5Cpartial%20%5Ctheta%7Dx%5Cright)"></p>
<p><strong>Computational advantage</strong>: Instead of solving <img src="https://latex.codecogs.com/png.latex?N"> forward problems (one for each design variable), we solve: 1. One forward problem: <img src="https://latex.codecogs.com/png.latex?Kx%20=%20B"> 2. One adjoint problem: <img src="https://latex.codecogs.com/png.latex?K%5ET%5Clambda%20=%20%5Cleft(%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20x%7D%5Cright)%5ET"></p>
<p>This gives us gradients with respect to all design variables at the cost of just two linear system solves, regardless of the number of design variables.</p>
</section>
<section id="automatic-differentiation-in-practice" class="level4">
<h4 class="anchored" data-anchor-id="automatic-differentiation-in-practice">Automatic Differentiation in Practice</h4>
<p><strong>Automatic Differentiation (AD)</strong> is a technique that automatically computes derivatives of functions implemented in computer code. Unlike symbolic differentiation (which manipulates mathematical expressions) or finite differences (which approximates derivatives), AD computes exact derivatives by applying the chain rule systematically through the computational graph.</p>
<p><strong>Two main modes of AD</strong>:</p>
<ol type="1">
<li><p><strong>Forward Mode AD</strong>: Computes directional derivatives by propagating derivatives forward through the computation. For a function <img src="https://latex.codecogs.com/png.latex?f:%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em">, forward mode computes <img src="https://latex.codecogs.com/png.latex?J%20%5Ccdot%20v"> where <img src="https://latex.codecogs.com/png.latex?J"> is the Jacobian and <img src="https://latex.codecogs.com/png.latex?v"> is a direction vector.</p></li>
<li><p><strong>Reverse Mode AD</strong>: Computes gradients by propagating adjoints backward through the computation. For a scalar function <img src="https://latex.codecogs.com/png.latex?f:%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D">, reverse mode computes <img src="https://latex.codecogs.com/png.latex?%5Cnabla%20f"> at the cost of approximately 2-4 function evaluations, regardless of <img src="https://latex.codecogs.com/png.latex?n">.</p></li>
</ol>
<p><strong>For our BEM solver</strong>, reverse mode AD is particularly attractive because: - We typically have many design variables (shape parameters) but few objectives - The computational cost is independent of the number of design variables - It naturally computes the adjoint variables needed for our optimization</p>
<p><strong>Implementation considerations</strong>:</p>
<ol type="1">
<li><strong>Language choice</strong>: Julia and JAX are excellent choices because they:
<ul>
<li>Support automatic differentiation natively</li>
<li>Provide high-performance numerical computing</li>
<li>Enable just-in-time compilation for efficiency</li>
<li>Offer parallel computing capabilities</li>
</ul></li>
<li><strong>Computational graph</strong>: The BEM solver must be implemented in a way that maintains a differentiable computational graph:
<ul>
<li>All operations must be differentiable</li>
<li>Control flow must be handled carefully</li>
<li>Linear solvers must be differentiable (or replaced with differentiable alternatives)</li>
</ul></li>
<li><strong>Memory considerations</strong>: Reverse mode AD requires storing intermediate values for the backward pass, which can be memory-intensive for large problems.</li>
</ol>
</section>
<section id="discrete-vs.-continuous-adjoint" class="level4">
<h4 class="anchored" data-anchor-id="discrete-vs.-continuous-adjoint">Discrete vs.&nbsp;Continuous Adjoint</h4>
<p><strong>Continuous adjoint</strong> methods derive adjoint equations from the continuous governing equations (PDEs) before discretization. This approach: - Provides analytical expressions for adjoint equations - May be more efficient for certain problems - Requires careful treatment of boundary conditions - Is problem-specific and requires manual derivation</p>
<p><strong>Discrete adjoint</strong> methods work with the discretized equations and use automatic differentiation to compute the required derivatives. This approach: - Is more general and applicable to many problems - Automatically handles complex discretization schemes - Requires less manual derivation - Can be less efficient but is more robust</p>
<p><strong>For our BEM solver</strong>, discrete adjoint with automatic differentiation is preferred because: - It handles the complex Green’s function evaluations automatically - It works with any objective function without manual derivation - It integrates seamlessly with existing optimization frameworks - It provides exact gradients (up to numerical precision)</p>
</section>
<section id="challenges-and-solutions" class="level4">
<h4 class="anchored" data-anchor-id="challenges-and-solutions">Challenges and Solutions</h4>
<p><strong>Challenge 1: Dense Linear Systems</strong> BEM methods solve dense linear systems, which are computationally expensive. Solutions include: - Using iterative solvers with preconditioning - Implementing matrix-free methods where possible - Leveraging parallel computing for large problems</p>
<p><strong>Challenge 2: Complex-valued Computations</strong> Hydrodynamic problems involve complex numbers (frequency domain analysis). AD frameworks must handle complex differentiation correctly: - Using Wirtinger calculus for complex derivatives - Ensuring proper handling of complex conjugates - Maintaining numerical stability</p>
<p><strong>Challenge 3: Green’s Function Evaluation</strong> The free-surface Green’s function is computationally expensive and involves special functions. - Implementing efficient evaluation algorithms - Using approximation methods for early design iterations - Leveraging GPU acceleration where possible</p>
<p><strong>Challenge 4: Integration with Optimization Frameworks</strong> The differentiable BEM solver must integrate with MDO frameworks like OpenMDAO: - Providing consistent interfaces for gradient computation - Handling the coupling between different subsystems - Ensuring numerical stability across the entire optimization</p>
</section>
</section>
</section>
<section id="optimization-problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="optimization-problem-statement">Optimization Problem Statement</h2>
<p>The hydrodynamic optimization problem can be expressed in general form as:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Baligned%7D%0A%5Cmin_%7B%5Ctheta,x%7D%20%5Cquad%20&amp;%20J(S(%5Ctheta),%20x(%5Ctheta);%20%5Ctheta%20)%20%5C%5C%0A%5Ctextrm%7Bs.t.%7D%20%5Cquad%20R(%5Ctheta)=%20%20&amp;%20K(%5Ctheta)%5Ctimes%20x(%5Ctheta)%20-%20B(%5Ctheta)%20=%200%20%5C%5C%0A%5Cend%7Baligned%7D"></p>
<p>Where: - <img src="https://latex.codecogs.com/png.latex?x"> is the state variable vector (e.g., source distribution) - <img src="https://latex.codecogs.com/png.latex?%5Ctheta"> represents mesh parameters (design variables) - <img src="https://latex.codecogs.com/png.latex?(K,%20S)"> are influence matrices (complex-valued) from free surface Green’s function evaluation and its derivative - <img src="https://latex.codecogs.com/png.latex?J"> is the objective function (e.g., Response Amplitude Operator)</p>
<p>In this optimization, residuals from <strong>dense linear systems</strong> are driven to zero iteratively using linear solvers:</p>
<p><img src="https://latex.codecogs.com/png.latex?R%20=%20K%20x%20-%20B"></p>
<p>Where <img src="https://latex.codecogs.com/png.latex?K"> is the square influence matrix between mesh panels (<img src="https://latex.codecogs.com/png.latex?N%20%5Ctimes%20N">), <img src="https://latex.codecogs.com/png.latex?B"> represents boundary conditions for diffraction and radiation problems, and <img src="https://latex.codecogs.com/png.latex?N"> is the number of mesh panels. <img src="https://latex.codecogs.com/png.latex?K">, <img src="https://latex.codecogs.com/png.latex?X">, and <img src="https://latex.codecogs.com/png.latex?B"> are explicitly related to mesh parameters <img src="https://latex.codecogs.com/png.latex?(%5Ctheta)">. The objective function thus depends both explicitly and implicitly on mesh parameters <img src="https://latex.codecogs.com/png.latex?(%5Ctheta)">.</p>
<p>For multidisciplinary design optimization including hydrodynamic optimization, the number of design variables increases further to account for system objectives and subsystem couplings.</p>
<p>For inverse design problems like this, calculating the gradient <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bd%20J%7D%7Bd%5Ctheta%7D"> involves computing <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20B%7D%7B%5Cpartial%20%5Ctheta%7D">, <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20K%7D%7B%5Cpartial%20%5Ctheta%7D">, <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20%5Ctheta%7D">, and <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Ctheta%7D">—which is only possible through automatic differentiation of the BEM solver.</p>
</section>
<section id="my-research-contribution" class="level2">
<h2 class="anchored" data-anchor-id="my-research-contribution">My Research Contribution</h2>
<p>When coupling BEM with other analyses, numerical derivatives such as finite differences can be used <span class="citation" data-cites="novelOpenMDAO">(Khanal and Haji 2023)</span>. I have already implemented this as the first version of my framework, but it has issues with accuracy and convergence and may not scale well for large numbers of design variables.</p>
<p>In contrast, the <strong>adjoint method</strong> requires only 2 solves of the linear system to obtain accurate gradients with respect to many design variables. A differentiable hydrodynamics solver is required to construct the adjoint equation.</p>
<p>Adjoint equations to minimize wave resistance of surface ships were derived by Ragab through continuous adjoint formulation <span class="citation" data-cites="Ragab_2004">(Ragab and Nayfeh 2004)</span>. However, this isn’t directly applicable to many offshore structures where different functionals (motions) are optimized. Unlike continuous formulation, <strong>discrete adjoint-based derivation using automatic differentiation</strong> is applicable to many objectives as long as they’re programmed in a language supporting automatic differentiation <span class="citation" data-cites="Adjoint_intro">(Giles and Pierce 2000)</span>.</p>
<p><strong>My thesis aims to implement a differentiable multidisciplinary design optimization framework that integrates gradient-based optimization for large-scale offshore systems.</strong></p>
<p>The proposed framework will:</p>
<ol type="1">
<li><strong>Implement a differentiable solver for hydrodynamics analysis</strong></li>
<li><strong>Derive, implement, and integrate adjoint-based shape optimization for offshore structures</strong></li>
<li><strong>Demonstrate differentiability and present case studies on optimization of novel offshore systems</strong></li>
</ol>
<p>Creating a differentiable boundary element method (BEM) solver will enable modern and complex workflows in offshore system design and optimization. <strong>Differentiability</strong> will allow for novel methods such as <strong>adjoint-based multidisciplinary optimization</strong> and more accurate data-driven methods such as <strong>physics-informed machine learning</strong>.</p>
<p>These capabilities will significantly reduce the design cycle for early design studies of novel offshore systems.</p>
</section>
<section id="research-phases" class="level2">
<h2 class="anchored" data-anchor-id="research-phases">Research Phases</h2>
<section id="phase-1-discrete-adjoint-implementation" class="level3">
<h3 class="anchored" data-anchor-id="phase-1-discrete-adjoint-implementation">Phase 1: Discrete Adjoint Implementation</h3>
<p>The <strong>first phase</strong> involves deriving and setting up discrete adjoint equations for BEM. We’ll use automatic differentiation to obtain partial sensitivities required in the equation by implementing the BEM method in either <strong>Julia</strong> or <strong>Jax</strong>, as they support automatic differentiation in a discretize-then-optimize scheme.</p>
<p>These libraries and programming languages support: - <strong>Automatic Differentiation (AD)</strong> - <strong>Parallelism</strong> - <strong>Just-in-time (JIT) compilation</strong></p>
<p>Gradient calculations need to be performed through the iterative solver employed to solve dense linear systems in BEM methods.</p>
<p>This method relies on known exact expressions of Green’s function. Mathematical expressions and numerical methods for free-surface Green’s function of linearized wave-structure problems in deep water and frequency domain are investigated <span class="citation" data-cites="Xie_2020">(Xie and Liu 2020)</span>. Other methods, such as approximating free-surface Green’s function using deep learning, can also be explored for early design iterations when speed is more important than accuracy.</p>
</section>
<section id="phase-2-mdo-framework-integration" class="level3">
<h3 class="anchored" data-anchor-id="phase-2-mdo-framework-integration">Phase 2: MDO Framework Integration</h3>
<p>The <strong>second phase</strong> integrates differentiable BEM into the MDO framework. Extensions could include supporting more accurate <strong>physics-informed machine learning</strong> <span class="citation" data-cites="three_NN_PDEs">(Raissi, Perdikaris, and Karniadakis 2019)</span>.</p>
<p>BEM methods require solving dense linear systems. The re-implementation will use algorithms best suited for dense matrices. A <strong>differentiable solver</strong> would provide required gradients for optimization and neural network-based approximation. Simulators implemented with automatic differentiation can be used inside machine learning models to construct more accurate reduced-order models <span class="citation" data-cites="solver_in_loop">(Brunton, Proctor, and Kutz 2020)</span>.</p>
</section>
<section id="expected-a-exam-scope" class="level3">
<h3 class="anchored" data-anchor-id="expected-a-exam-scope">Expected A-Exam Scope</h3>
<p>I plan to take an A-exam in Spring 2024, presenting the differentiable version of the solver that derives discrete adjoints for the hydrodynamic solver using automatic differentiation in Jax or Julia.</p>
<p>An optimization study of simple geometry (such as a compound cylinder) with analytical derivation through eigenfunction expansion will be conducted for gradient verification. Gradients will be compared with finite differences for geometries where analytical gradients are unavailable.</p>
</section>
</section>
<section id="tentative-thesis-chapters" class="level2">
<h2 class="anchored" data-anchor-id="tentative-thesis-chapters">Tentative Thesis Chapters</h2>
<ol type="1">
<li><strong>Multidisciplinary Design Optimization of Offshore Systems</strong> - Literature review</li>
<li><strong>Boundary Element Method for Calculating Hydrodynamic Coefficients</strong></li>
<li><strong>Adjoint and Automatic Differentiation of BEM Solver</strong></li>
<li><strong>Case Studies and Applications of a Differentiable Solver</strong></li>
</ol>
</section>
<section id="keywords" class="level2">
<h2 class="anchored" data-anchor-id="keywords">Keywords</h2>
<p>Differentiable Hydrodynamics, Multidisciplinary Design Optimization, Automatic Differentiation, Discrete Adjoint Method, Boundary Element Method, Potential Flow, Panel Code</p>
<hr>
<p><em>This research is conducted as part of my PhD in Systems Engineering at Cornell University, under the supervision of Dr.&nbsp;Maha Haji in the Symbiotic Engineering and Analysis Lab.</em></p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-babarit_theoretical_2015" class="csl-entry">
Babarit, Aurélien. 2015. <span>“Theoretical and Numerical Aspects of the Open Source BEM Solver NEMOH.”</span> <em>Proceedings of the 11th European Wave and Tidal Energy Conference</em>.
</div>
<div id="ref-BEMcomparison" class="csl-entry">
Babarit, Aurélien, and Gérard Delhommeau. 2011. <span>“Comparison of Boundary Element Method and Finite Element Method for Hydrodynamic Analysis of Floating Bodies.”</span> <em>Engineering Analysis with Boundary Elements</em> 35 (3): 419–28.
</div>
<div id="ref-solver_in_loop" class="csl-entry">
Brunton, Steven L, Joshua L Proctor, and J Nathan Kutz. 2020. <span>“Neural Networks as Surrogate Models for Simulations in Engineering.”</span> <em>Annual Review of Fluid Mechanics</em> 52: 477–508.
</div>
<div id="ref-Adjoint_intro" class="csl-entry">
Giles, Michael B, and Niles A Pierce. 2000. <span>“An Introduction to the Adjoint Approach to Design.”</span> <em>Flow, Turbulence and Combustion</em> 65 (3): 393–415.
</div>
<div id="ref-Gray2019a" class="csl-entry">
Gray, Justin S, John T Hwang, Joaquim RR Martins, Kenneth T Moore, and Bret A Naylor. 2019. <span>“OpenMDAO: An Open-Source Framework for Multidisciplinary Design, Analysis, and Optimization.”</span> <em>Structural and Multidisciplinary Optimization</em> 59 (4): 1075–1104.
</div>
<div id="ref-Haghi_2014" class="csl-entry">
Haghi, Reza, Saeed-Reza Sabbagh-Yazdi, and Mohammad Ghalandari. 2014. <span>“Hydrodynamic Analysis of Spar-Type Floating Offshore Wind Turbines.”</span> <em>Ocean Engineering</em> 89: 1–10.
</div>
<div id="ref-DAFoam" class="csl-entry">
He, Ping, Charles A Mader, Joaquim RR Martins, and Kevin J Maki. 2020. <span>“DAFoam: An Open-Source Adjoint Framework for Multidisciplinary Design Optimization with OpenFOAM.”</span> <em>AIAA Journal</em> 58 (3): 1304–19.
</div>
<div id="ref-maud" class="csl-entry">
Hwang, John T, and Joaquim RR Martins. 2018. <span>“Modular Analysis and Unified Derivatives.”</span> <em>Structural and Multidisciplinary Optimization</em> 57 (3): 1079–1107.
</div>
<div id="ref-jameson" class="csl-entry">
Jameson, Antony. 1988. <span>“Aerodynamic Design via Control Theory.”</span> <em>Journal of Scientific Computing</em> 3 (3): 233–60.
</div>
<div id="ref-novelOpenMDAO" class="csl-entry">
Khanal, Kapil, and Maha Haji. 2023. <span>“Novel OpenMDAO Framework for Multidisciplinary Design Optimization of Offshore Systems.”</span> <em>Proceedings of the ASME 2023 42nd International Conference on Ocean, Offshore and Arctic Engineering</em>.
</div>
<div id="ref-mdobook" class="csl-entry">
Martins, Joaquim RR, and Andrew B Lambe. 2013. <em>Multidisciplinary Design Optimization: State of the Art</em>. SIAM.
</div>
<div id="ref-morison_force_1950" class="csl-entry">
Morison, James R, James W Johnson, and Stephen A Schaaf. 1950. <span>“The Force Exerted by Surface Waves on Piles.”</span> <em>Journal of Petroleum Technology</em> 2 (05): 149–54.
</div>
<div id="ref-roadmapNREL" class="csl-entry">
Musial, Walter, Philipp Beiter, Paul Spitsen, and Jake Nunemaker. 2020. <span>“Offshore Wind Energy Roadmap.”</span> <em>National Renewable Energy Laboratory</em>.
</div>
<div id="ref-Multipurpose" class="csl-entry">
Perez-Collazo, Carlos, Deborah Greaves, and Gregorio Iglesias. 2015. <span>“Multipurpose Platforms for Marine Renewable Energy.”</span> <em>Renewable and Sustainable Energy Reviews</em> 54: 784–97.
</div>
<div id="ref-Ragab_2004" class="csl-entry">
Ragab, Saad A, and Ali H Nayfeh. 2004. <span>“Adjoint-Based Optimization of Wave Resistance.”</span> <em>Journal of Ship Research</em> 48 (1): 1–15.
</div>
<div id="ref-three_NN_PDEs" class="csl-entry">
Raissi, Maziar, Paris Perdikaris, and George E Karniadakis. 2019. <span>“Physics-Informed Neural Networks: A Deep Learning Framework for Solving Forward and Inverse Problems Involving Nonlinear Partial Differential Equations.”</span> <em>Journal of Computational Physics</em> 378: 686–707.
</div>
<div id="ref-Samareh_2001" class="csl-entry">
Samareh, Jamshid A. 2001. <span>“Survey of Shape Parameterization Techniques for High-Fidelity Multidisciplinary Shape Optimization.”</span> <em>AIAA Journal</em> 39 (5): 877–84.
</div>
<div id="ref-mdo_1993" class="csl-entry">
Sobieszczanski-Sobieski, Jaroslaw, and Raphael T Haftka. 1993. <span>“Multidisciplinary Design Optimization: An Emerging New Engineering Discipline.”</span> <em>Advances in Structural Optimization</em>, 483–96.
</div>
<div id="ref-Xie_2020" class="csl-entry">
Xie, Zhiming, and Yuming Liu. 2020. <span>“Mathematical Expressions and Numerical Methods for the Free-Surface Green Function of the Linearized Wave-Structure Problem.”</span> <em>Journal of Engineering Mathematics</em> 120 (1): 1–25.
</div>
</div></section></div> ]]></description>
  <category>research</category>
  <category>optimization</category>
  <category>hydrodynamics</category>
  <category>thesis</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/differentiable-hydrodynamics-framework/</guid>
  <pubDate>Mon, 15 Jan 2024 00:00:00 GMT</pubDate>
  <media:content url="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/differentiable-hydrodynamics-framework" medium="image"/>
</item>
<item>
  <title>eVTOL Integration in Emergency Medical Services: A System Architecture Approach</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/evtol-ems-system-architecture/</link>
  <description><![CDATA[ 




<section id="project-overview" class="level2">
<h2 class="anchored" data-anchor-id="project-overview">Project Overview</h2>
<p><strong>We propose to architect a system that integrates eVTOLs in emergency medical services to ensure affordability, performance, and equity.</strong> The technical, operational, and regulatory requirements of the EMS services are fundamentally different and stringent from the air-taxi requirements, thus a design of system architecture is important. The successful integration of the air ambulance in the city emergency services will save countless lives by reducing the response time and safe transportation.</p>
</section>
<section id="project-scope" class="level2">
<h2 class="anchored" data-anchor-id="project-scope">Project Scope</h2>
<p>The scope of the project is to successfully realize an integrated system of air transport for emergency medical services. It will develop models and methods necessary to deploy emergency services using the appropriate air vehicle in the urban environment. We will simulate the operational and design decisions to enumerate the architectures.</p>
<p>The main function of this system is transporting (process) a patient (operand) or providing immediate medical attention (process) to the hospital (operand). Our goal is to provide insight for all the stakeholders about the promise and potential of eVTOL-based emergency services and propose several reference architectures.</p>
</section>
<section id="system-architecture-poster" class="level2">
<h2 class="anchored" data-anchor-id="system-architecture-poster">System Architecture Poster</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
System Architecture Poster
</div>
</div>
<div class="callout-body-container callout-body">
<p>The following poster presents our comprehensive system architecture for integrating eVTOLs into emergency medical services:</p>
</div>
</div>
<div id="poster-embed">
<iframe src="System_Architecture_Poster.pdf" width="100%" height="800px" style="border: 1px solid #ddd; border-radius: 8px;">
</iframe>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Alternative Viewing Options
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>Full Screen</strong>: <a href="System_Architecture_Poster.pdf" target="_blank">Open poster in new tab</a></li>
<li><strong>Download</strong>: <a href="System_Architecture_Poster.pdf">Download PDF file</a></li>
</ul>
</div>
</div>
</section>
<section id="key-research-areas" class="level2">
<h2 class="anchored" data-anchor-id="key-research-areas">Key Research Areas</h2>
<section id="system-architecture-design" class="level3">
<h3 class="anchored" data-anchor-id="system-architecture-design">1. System Architecture Design</h3>
<ul>
<li><strong>Multi-stakeholder Analysis</strong>: Understanding the needs of patients, healthcare providers, emergency responders, and regulatory bodies</li>
<li><strong>Operational Modeling</strong>: Developing simulation frameworks for emergency response scenarios</li>
<li><strong>Infrastructure Planning</strong>: Designing vertiport networks and medical facility integration</li>
</ul>
</section>
<section id="technical-requirements" class="level3">
<h3 class="anchored" data-anchor-id="technical-requirements">2. Technical Requirements</h3>
<ul>
<li><strong>Vehicle Specifications</strong>: eVTOL design requirements for medical transport</li>
<li><strong>Safety Standards</strong>: Regulatory compliance and certification pathways</li>
<li><strong>Performance Metrics</strong>: Response time optimization and reliability requirements</li>
</ul>
</section>
<section id="operational-considerations" class="level3">
<h3 class="anchored" data-anchor-id="operational-considerations">3. Operational Considerations</h3>
<ul>
<li><strong>Dispatch Algorithms</strong>: Intelligent routing and resource allocation</li>
<li><strong>Medical Integration</strong>: Coordination with existing emergency medical systems</li>
<li><strong>Cost-Benefit Analysis</strong>: Economic feasibility and sustainability models</li>
</ul>
</section>
<section id="equity-and-accessibility" class="level3">
<h3 class="anchored" data-anchor-id="equity-and-accessibility">4. Equity and Accessibility</h3>
<ul>
<li><strong>Geographic Coverage</strong>: Ensuring service availability across diverse urban areas</li>
<li><strong>Affordability Models</strong>: Making emergency air transport accessible to all communities</li>
<li><strong>Regulatory Framework</strong>: Policy recommendations for equitable service delivery</li>
</ul>
</section>
</section>
<section id="research-methodology" class="level2">
<h2 class="anchored" data-anchor-id="research-methodology">Research Methodology</h2>
<p>Our approach combines several analytical frameworks:</p>
<ol type="1">
<li><strong>Systems Engineering</strong>: Structured approach to complex system design</li>
<li><strong>Operations Research</strong>: Mathematical modeling of emergency response networks</li>
<li><strong>Stakeholder Analysis</strong>: Understanding diverse requirements and constraints</li>
<li><strong>Simulation Modeling</strong>: Virtual testing of system architectures and operational scenarios</li>
</ol>
</section>
<section id="expected-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="expected-outcomes">Expected Outcomes</h2>
<p>This research will deliver:</p>
<ul>
<li><strong>Reference Architectures</strong>: Multiple system design options for eVTOL EMS integration</li>
<li><strong>Performance Models</strong>: Quantitative analysis of response times and service quality</li>
<li><strong>Implementation Roadmap</strong>: Step-by-step guidance for system deployment</li>
<li><strong>Policy Recommendations</strong>: Regulatory and operational guidelines for stakeholders</li>
</ul>
</section>
<section id="impact-and-significance" class="level2">
<h2 class="anchored" data-anchor-id="impact-and-significance">Impact and Significance</h2>
<p>The integration of eVTOLs into emergency medical services has the potential to:</p>
<ul>
<li><strong>Reduce Response Times</strong>: Faster emergency response in urban and rural areas</li>
<li><strong>Improve Patient Outcomes</strong>: Quicker access to specialized medical care</li>
<li><strong>Enhance System Efficiency</strong>: Better resource utilization and coordination</li>
<li><strong>Promote Equity</strong>: Extend high-quality emergency care to underserved communities</li>
</ul>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future Work</h2>
<p>Building on this system architecture study, future research directions include:</p>
<ul>
<li><strong>Pilot Program Design</strong>: Implementation of small-scale demonstration projects</li>
<li><strong>Technology Development</strong>: Advancement of eVTOL capabilities for medical applications</li>
<li><strong>Partnership Development</strong>: Collaboration with healthcare providers and regulatory agencies</li>
<li><strong>Economic Analysis</strong>: Detailed cost-benefit studies for different deployment scenarios</li>
</ul>
<hr>
<p><em>This work represents a comprehensive approach to integrating emerging air mobility technologies with critical healthcare infrastructure, with the ultimate goal of improving emergency medical services for all communities.</em></p>
</section>
<section id="related-publications" class="level2">
<h2 class="anchored" data-anchor-id="related-publications">Related Publications</h2>
<p>This research builds on and contributes to the broader field of urban air mobility and emergency services integration. For more information about related work in this area, please refer to the publications section of this website.</p>


</section>

 ]]></description>
  <category>system architecture</category>
  <category>eVTOL</category>
  <category>systems engineering</category>
  <category>urban mobility</category>
  <category>research</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/evtol-ems-system-architecture/</guid>
  <pubDate>Tue, 19 Dec 2023 00:00:00 GMT</pubDate>
  <media:content url="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/evtol-ems-system-architecture/evtol.png" medium="image" type="image/png" height="96" width="144"/>
</item>
<item>
  <title>Giving Passes Due Credit: A Data-Driven Framework to Calculate Expected Goals Per Pass (xG/pass)</title>
  <dc:creator>Kapil Khanal</dc:creator>
  <link>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/</link>
  <description><![CDATA[ 




<p>This is a project I did for my summer undergraduate experience in statistics at Carnegie Mellon University. This project can be extended to create a dynamic network model of the game if you’re interested in that and I am open to collaborate on that especially if you’re a undergraduate researcher.</p>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>Finding the value of a pass is a holy grail of soccer analytics. While Expected Goals (xG) is a ubiquitous metric for measuring the quality of a shot, it primarily rewards the player taking the shot, often overlooking the crucial build-up play. Soccer is a collaborative game, and the passes leading to a shot are often as important as the shot itself. To create a more complete picture, we need to give passes their due credit.</p>
<p>This paper proposes a data-driven framework to calculate an “Expected Goal per Pass” (<em>xG/pass</em>) value, distributing the credit for a scoring opportunity across all players involved in the passing sequence.</p>
<p><strong>Keywords</strong>: <em>xG per pass, credit assignment, data driven, soccer analytics</em></p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>A pass in soccer can be evaluated in terms of its risk and reward. In this paper, we propose a data-driven methodology to assign an Expected Goal (xG) value to each pass made by a player. The framework considers the quality of the pass, the collaboration within the team, and the spatial context of where the pass was made on the pitch.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/soccer.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Let’s kick it</figcaption>
</figure>
</div>
<p>Various methods have been proposed to solve this credit assignment problem. One common approach is to simply attribute a fraction of the final shot’s xG to players who assisted. However, this method often fails to account for the quality of the individual passes and tends to over-reward forward players who are closer to the final action. Our framework aims to provide a more nuanced distribution of credit.</p>
</section>
<section id="dataset-statsbomb-event-data" class="level2">
<h2 class="anchored" data-anchor-id="dataset-statsbomb-event-data">Dataset: StatsBomb Event Data</h2>
<p>We used event data from <a href="httpss://statsbomb.com/">StatsBomb</a>’s open data resources. This dataset logs every event in a match, including timestamps, player actions, and locations. We focused our analysis on “pass chains”—sequences of passes within a single team’s possession.</p>
<p>A pass chain can originate anywhere on the field and may or may not end in a shot. When a chain does end in a shot, the entire sequence inherits the xG value of that shot.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Placeholder for Figure 1: Pass Chain Example
</div>
</div>
<div class="callout-body-container callout-body">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/pass.png" class="img-fluid figure-img"></p>
<figcaption>Pass Chain Example</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="methods-for-distributing-xg" class="level2">
<h2 class="anchored" data-anchor-id="methods-for-distributing-xg">Methods for Distributing xG</h2>
<p>We explored several statistical methods to model the value of each pass within a chain.</p>
<section id="grid-based-model" class="level3">
<h3 class="anchored" data-anchor-id="grid-based-model">1. Grid-Based Model</h3>
<p>The most intuitive approach is to divide the pitch into a grid and calculate the average xG of all pass chains originating from each grid cell. This value is then assigned to any pass starting in that cell. We used cross-validation to determine the optimal grid size.</p>
<p>While simple, this model assumes all passes from a given area are equal, which ignores individual pass quality and player skill.</p>
</section>
<section id="generalized-additive-model-gam" class="level3">
<h3 class="anchored" data-anchor-id="generalized-additive-model-gam">2. Generalized Additive Model (GAM)</h3>
<p>To capture the non-linear relationship between pass location and its value, we used a Generalized Additive Model (GAM). This model provides a smooth estimate of xG across the entire pitch based on the precise starting coordinates of a pass.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Placeholder for Figure 3: GAM Smooth Estimates
</div>
</div>
<div class="callout-body-container callout-body">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/gam.png" class="img-fluid figure-img"></p>
<figcaption>GAM Smooth Estimates</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="random-forest-model" class="level3">
<h3 class="anchored" data-anchor-id="random-forest-model">3. Random Forest Model</h3>
<p>Finally, we built a Random Forest model to incorporate a richer set of features beyond just location. These features included: - <strong>Pass Length and Duration</strong>: How far and how quickly the ball traveled. - <strong>Network Metrics</strong>: We constructed a passing network for each team to measure player influence. Metrics like <strong>PageRank</strong> and <strong>Betweenness Centrality</strong> were calculated for each player (node) in the network.</p>
<p>The model, built with 500 trees, prioritized pass location and the PageRank of the receiving player, indicating that high-value passes are those made near the opponent’s goal to influential players.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Placeholder for Figure 4 &amp; 5: Network and Feature Importance
</div>
</div>
<div class="callout-body-container callout-body">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/network.png" class="img-fluid figure-img"></p>
<figcaption>Network and Feature Importance</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="model-comparison" class="level2">
<h2 class="anchored" data-anchor-id="model-comparison">Model Comparison</h2>
<p>We compared the models using Mean Squared Error (MSE) on a 70/30 train-test split. The Random Forest model performed the best, confirming the presence of non-linear relationships in the data.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Model</th>
<th>MSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Grid-Based Model</td>
<td>0.043</td>
</tr>
<tr class="even">
<td>Generalized Additive Model</td>
<td>0.0034</td>
</tr>
<tr class="odd">
<td><strong>Random Forest Model</strong></td>
<td><strong>0.0024</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="creating-the-final-xg-per-pass-metric" class="level2">
<h2 class="anchored" data-anchor-id="creating-the-final-xg-per-pass-metric">Creating the Final <em>xG per Pass</em> Metric</h2>
<p>Using the predictions from our Random Forest model, we re-normalized the values within each pass chain to create the final metric. The formula is:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ctextit%7BxG%20per%20pass%7D_%7Bi%7D%20=%20%5Cfrac%7Bf(%5Ctext%7Bpass%7D_i)%7D%7B%5Csum_%7Bj=1%7D%5E%7Bn%7Df(%5Ctext%7Bpass%7D_%7Bj%7D)%7D%20%5Ctimes%20%5Ctextit%7BxG%20from%20shot%7D%0A"></p>
<p>where <img src="https://latex.codecogs.com/png.latex?f(%5Ctext%7Bpass%7D_i)"> is the predicted value for pass <em>i</em> from the model, and <em>n</em> is the total number of passes in the chain.</p>
</section>
<section id="conclusion-and-future-work" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-and-future-work">Conclusion and Future Work</h2>
<p>This framework provides a quantitative method to credit players for their contribution to creating scoring chances. It rewards passes made closer to the opponent’s goal and those made to influential teammates. This metric can be used to rank players based on their creative passing ability.</p>
<p>For future work, we plan to incorporate team tactics, the positions of nearby players, and a method to penalize “bad” passes that result in a loss of possession.</p>
<section id="code-for-analysis" class="level3">
<h3 class="anchored" data-anchor-id="code-for-analysis">Code for Analysis</h3>
<p>The code for this project is available on GitHub: <a href="https://github.com/KapilKhanal/Soccer_CMUCamp">https://github.com/KapilKhanal/Soccer_CMUCamp</a></p>
</section>
<section id="acknowledgements" class="level3">
<h3 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h3>
<p>I would like to thank Dr.&nbsp;Kostas Pelechrinis of the University of Pittsburgh for helping with the project and Dr.&nbsp;Tisha Hooks of Winona State University for reviewing the paper. This paper is a continuation of the work I did for my summer undergraduate experience in statistics at Carnegie Mellon University.</p>


</section>
</section>

 ]]></description>
  <category>data science</category>
  <category>sports analytics</category>
  <category>soccer</category>
  <category>research</category>
  <guid>https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/</guid>
  <pubDate>Sat, 01 Feb 2020 00:00:00 GMT</pubDate>
  <media:content url="https://github.com/KapilKhanal/kapilkhanal.github.io/posts/xg-pass-soccer-analytics/pass.png" medium="image" type="image/png" height="92" width="144"/>
</item>
</channel>
</rss>
